# Doc & Github Ref [as per the doc schema store with graphqls not with graphql]
# Postman use the graphql not the graphqls
# https://graphql.org/learn/schema/#object-types-and-fields [use for create the graphql]
# https://github.com/Amit-Chavda/todo-app-grapql [use for graphql custom scalar in java]
# https://github.com/rrohitramsen/ems [use for ems]
scalar LocalDate
scalar LocalDateTime

# Enums
enum Format {
    HARD_COVER
    PAPER_BACK
    EBOOK
}

enum Language {
    ENGLISH
    SPANISH
    ARABIC
}

enum Category {
    FICTION
    NO_FICTION
    MYSTERY
    SCIENCE_FICTION
}

enum Status {
    INACTIVE
    ACTIVE
    DELETE
}

# Custom Enum Types
type GFormat {
    code: Int!
    name: String!
    value: Format!
}

type GLanguage {
    code: Int!
    name: String!
    value: Language!
}

type GCategory {
    code: Int!
    name: String!
    value: Category!
}

type GStatus {
    code: Int!
    name: String!
    value: Status!
}

# BaseEntity Interface
interface BaseEntity {
    id: ID!
    createdAt: LocalDateTime!
    updatedAt: LocalDateTime!
    status: GStatus!
}

# Response Union
union DATA = AuthorResponse | AuthorListResponse | BookResponse | BookListResponse

# Response Type
type QLResponse {
    message: String!
    status: String!
    data: DATA
}

# Author Response Type
type AuthorResponse implements BaseEntity {
    id: ID!
    firstName: String
    lastName: String!
    email: String!
    username: String!
    biography: String
    nationality: String!
    expertise: String
    image: String
    books: [BookResponse]!
    createdAt: LocalDateTime!
    updatedAt: LocalDateTime!
    status: GStatus!
}

type AuthorListResponse {
    authors: [AuthorResponse]!
}

# Book Response Type
type BookResponse implements BaseEntity {
    id: ID!
    isbn: String!
    title: String!
    price: Float!
    publisher: String!
    publication: LocalDate!
    language: GLanguage!
    category: GCategory!
    format: GFormat!
    description: String!
    coverImg: String!
    bookUrl: String!
    note: String
    author: AuthorResponse!
    createdAt: LocalDateTime!
    updatedAt: LocalDateTime!
    status: GStatus!
}

type BookListResponse {
    books: [BookResponse]!
}

# Input Types
input BookRequest {
    id: ID
    isbn: String
    title: String
    price: Float
    publisher: String
    publication: LocalDate
    language: Language
    category: Category
    format: Format
    description: String
    note: String
    author: AuthorRequest
    status: Status
}

input AuthorRequest {
    id: ID
    firstName: String
    lastName: String
    email: String
    password: String
    username: String
    biography: String
    nationality: String
    expertise: String
    status: Status
}

# Mutation API
type Mutation {
    createAuthor(author: AuthorRequest!): QLResponse
    updateAuthor(author: AuthorRequest!): QLResponse
    deleteAuthor(id: ID!): QLResponse
    createBook(book: BookRequest!): QLResponse
    updateBook(book: BookRequest!): QLResponse
    deleteBook(id: ID!): QLResponse
}

# Query API
type Query {
    # secure ql only access after login
    getAuthor(id: ID!): QLResponse
    getAllAuthors: QLResponse
    getBook(id: ID!): QLResponse
    getAllBooks: QLResponse
    # public ql
    fetchPublicBooks: QLResponse
    fetchPublicAuthors: QLResponse
}

# Schema Entry Point
schema {
    query: Query
    mutation: Mutation
}